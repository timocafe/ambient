/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2015.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef AMBIENT_CONTAINER_NUMERIC_BINDINGS_MKL
#define AMBIENT_CONTAINER_NUMERIC_BINDINGS_MKL

#define MKL_INT int
#define MKL_Complex16 std::complex<double>

extern "C" {

    void dgemm(const char* transa, const char* transb, const MKL_INT* m, const MKL_INT* n, const MKL_INT* k,
        const double* alpha, const double* a, const MKL_INT* lda, const double* b, const MKL_INT* ldb,
        const double* beta, double* c, const MKL_INT* ldc);

    void zgemm(const char* transa, const char* transb, const MKL_INT* m, const MKL_INT* n, const MKL_INT* k,
        const MKL_Complex16* alpha, const MKL_Complex16* a, const MKL_INT* lda,
        const MKL_Complex16* b, const MKL_INT* ldb, const MKL_Complex16* beta,
        MKL_Complex16* c, const MKL_INT* ldc);

    void dgemv(const char* trans, const MKL_INT* m, const MKL_INT* n, const double* alpha,
        const double* a, const MKL_INT* lda, const double* x, const MKL_INT* incx,
        const double* beta, double* y, const MKL_INT* incy);

    void zgemv(const char* trans, const MKL_INT* m, const MKL_INT* n, const MKL_Complex16* alpha,
        const MKL_Complex16* a, const MKL_INT* lda, const MKL_Complex16* x, const MKL_INT* incx,
        const MKL_Complex16* beta, MKL_Complex16* y, const MKL_INT* incy);

    void daxpy(const MKL_INT* n, const double* alpha, const double* x, const MKL_INT* incx, double* y, const MKL_INT* incy);

    void zaxpy(const MKL_INT* n, const MKL_Complex16* alpha, const MKL_Complex16* x, const MKL_INT* incx, MKL_Complex16* y, const MKL_INT* incy);

    void dgesvd(const char* jobu, const char* jobvt, const MKL_INT* m,
        const MKL_INT* n, double* a, const MKL_INT* lda, double* s,
        double* u, const MKL_INT* ldu, double* vt, const MKL_INT* ldvt,
        double* work, const MKL_INT* lwork, MKL_INT* info);

    void zgesvd(const char* jobu, const char* jobvt, const MKL_INT* m,
        const MKL_INT* n, MKL_Complex16* a, const MKL_INT* lda, double* s,
        MKL_Complex16* u, const MKL_INT* ldu, MKL_Complex16* vt,
        const MKL_INT* ldvt, MKL_Complex16* work, const MKL_INT* lwork,
        double* rwork, MKL_INT* info);

    void dsyev(const char* jobz, const char* uplo, const MKL_INT* n, double* a,
        const MKL_INT* lda, double* w, double* work, const MKL_INT* lwork,
        MKL_INT* info);

    void zheev(const char* jobz, const char* uplo, const MKL_INT* n,
        MKL_Complex16* a, const MKL_INT* lda, double* w,
        MKL_Complex16* work, const MKL_INT* lwork, double* rwork,
        MKL_INT* info);

    void zgeev(const char* jobvl, const char* jobvr, const MKL_INT* n,
        MKL_Complex16* a, const MKL_INT* lda, MKL_Complex16* w,
        MKL_Complex16* vl, const MKL_INT* ldvl, MKL_Complex16* vr,
        const MKL_INT* ldvr, MKL_Complex16* work, const MKL_INT* lwork,
        double* rwork, MKL_INT* info);

    void dgetrf(const MKL_INT* m, const MKL_INT* n, double* a, const MKL_INT* lda,
        MKL_INT* ipiv, MKL_INT* info);

    void zgetrf(const MKL_INT* m, const MKL_INT* n, MKL_Complex16* a,
        const MKL_INT* lda, MKL_INT* ipiv, MKL_INT* info);

    void dgetri(const MKL_INT* n, double* a, const MKL_INT* lda,
        const MKL_INT* ipiv, double* work, const MKL_INT* lwork,
        MKL_INT* info);

    void zgetri(const MKL_INT* n, MKL_Complex16* a, const MKL_INT* lda,
        const MKL_INT* ipiv, MKL_Complex16* work, const MKL_INT* lwork,
        MKL_INT* info);

}

#undef MKL_INT
#undef MKL_Complex16

namespace ambient {
    inline namespace numeric {
        namespace mkl {

            template<class T, class D>
            struct helper_cast;

            template<>
            struct helper_cast<std::complex<double>, double> {
                typedef std::complex<double> T;
                typedef double D;
                static T cast(D a) { return static_cast<T>(a); }
            };

            template<>
            struct helper_cast<double, std::complex<double>> {
                typedef double T;
                typedef std::complex<double> D;
                static T cast(D a) { return a.real(); }
            };

            template<>
            struct helper_cast<double, double> {
                typedef double T;
                typedef double D;
                static T cast(T a) { return a; }
            };

            template<>
            struct helper_cast<std::complex<double>, std::complex<double>> {
                typedef std::complex<double> T;
                typedef std::complex<double> D;
                static T cast(T a) { return a; }
            };

            template <class T>
            inline int OptimalSize(T a) { return (int)a; }

            template <class T>
            inline int OptimalSize(std::complex<T> a) { return (int)a.real(); }

            template<class T>
            struct helper_complex;

            template<>
            struct helper_complex<double> {
                typedef double T;
                static inline T conj(T x) { return x; }
                static inline T real(T x) { return x; }
            };

            template<>
            struct helper_complex<std::complex<double> > {
                typedef std::complex<double> T;
                static inline T conj(T x) { return std::conj(x); }
                static inline T real(T x) { return std::real(x); }
            };

            template<class T>
            struct blas;

            template<>
            struct blas<double> {
                typedef double T;
                static void gemm(const char* transa, const char* transb, const int* m, const int* n, const int* k, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc) {
                    dgemm(transa, transb, m, n, k, alfa, ad, lda, bd, ldb, beta, cd, ldc);
                }

                static void gemv(const char* transa, const int* m, const int* n, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc) {
                    dgemv(transa, m, n, alfa, ad, lda, bd, ldb, beta, cd, ldc);
                }

                static void axpy(const int* n, const double* alfa, const T* ad, const int* inca, T* bd, const int* incb) {
                    daxpy(n, alfa, ad, inca, bd, incb);
                }

            };

            template<>
            struct blas<std::complex<double> > {
                typedef std::complex<double> T;
                static void gemm(const char* transa, const char* transb, const int* m, const int* n, const int* k, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc) {
                    zgemm(transa, transb, m, n, k, alfa, ad, lda, bd, ldb, beta, cd, ldc);
                }

                static void gemv(const char* transa, const int* m, const int* n, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc) {
                    zgemv(transa, m, n, alfa, ad, lda, bd, ldb, beta, cd, ldc);
                }

                static void axpy(const int* n, const T* alfa, const T* ad, const int* inca, T* bd, const int* incb) { // exp algorithm only
                    zaxpy(n, alfa, ad, inca, bd, incb);
                }

                static void axpy(const int* n, const typename T::value_type* alfa, const T* ad, const int* inca, T* bd, const int* incb) { // after SVD complex
                    T beta(*alfa);
                    zaxpy(n, &beta, ad, inca, bd, incb);
                }
            };

            template<class T>
            struct lapack;

            template<>
            struct lapack<double> {
                typedef double T;
                static void gesvd(const char* jobu, const char* jobvt, const int* m, const int* n, T* ad, const int* lda, T* sd, T* ud, const int* ldu, T* vtd, const int* ldvt, T* wkopt, int* lwork, int* info) {
                    T* work;
                    dgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, wkopt, lwork, info);
                    *lwork = OptimalSize(*wkopt);
                    work = (T*)std::malloc((*lwork) * sizeof(T));
                    dgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, work, lwork, info);
                    assert(*info == 0); // otherwise SVD hasn't converged
                    std::free(work);
                }

                static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, T* w, T* wkopt, int* lwork, int* info) {
                    T* work;
                    dsyev(jobz, uplo, n, a, lda, w, wkopt, lwork, info);
                    assert(*info == 0);
                    *lwork = OptimalSize(*wkopt);
                    work = (T*)std::malloc((*lwork) * sizeof(T));
                    dsyev(jobz, uplo, n, a, lda, w, work, lwork, info);
                    assert(*info == 0);
                    std::free(work);
                }

                static void getrf(const int* m, const int* n, T* a, const int* lda, int* ipiv, int* info) {
                    dgetrf(m, n, a, lda, ipiv, info);
                    assert(*info == 0);
                }

                static void getri(const int* n, T* a, const int* lda, int* ipiv, int* info) {
                    T* work;
                    T wkopt;
                    int lwork = -1;
                    dgetri(n, a, lda, ipiv, &wkopt, &lwork, info);
                    assert(*info == 0);
                    lwork = OptimalSize(wkopt);
                    work = (T*)std::malloc(lwork * sizeof(T));
                    dgetri(n, a, lda, ipiv, work, &lwork, info);
                    assert(*info == 0);
                    std::free(work);
                }
            };

            template<>
            struct lapack<std::complex<double> > {
                typedef std::complex<double> T;
                static void gesvd(const char* jobu, const char* jobvt, const int* m, const int* n, T* ad, const int* lda, typename T::value_type* sd, T* ud, const int* ldu, T* vtd, const int* ldvt, T* wkopt, int* lwork, int* info) {
                    typename T::value_type* rwork = new typename T::value_type[std::max(1, 5 * std::min((*n), (*m)))]; // as of MKL doc
                    T* work;
                    zgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, wkopt, lwork, rwork, info); // query the optimal workspace
                    assert(*info == 0);
                    *lwork = OptimalSize(*wkopt);
                    work = (T*)std::malloc((*lwork) * sizeof(T));
                    zgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, work, lwork, rwork, info);
                    assert(*info == 0); // otherwise SVD hasn't converged
                    std::free(work);
                    delete[] rwork;
                }

                static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, typename T::value_type* w, T* wkopt, int* lwork, int* info) {
                    typename T::value_type* rwork = new typename T::value_type[std::max(1, 3 * (*n) - 2)]; // as of MKL doc
                    T* work;
                    zheev(jobz, uplo, n, a, lda, w, wkopt, lwork, rwork, info);
                    assert(*info == 0);
                    *lwork = OptimalSize(*wkopt);
                    work = (T*)std::malloc((*lwork) * sizeof(T));
                    zheev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info);
                    assert(*info == 0);
                    std::free(work);
                    delete[] rwork;
                }

                static void geev(const char* jobvl, const char* jobvr, const int* n, T* a, const int* lda, T* s, T* ldv, const int* ldlv, T* rvd, const int* ldrv, T* wkopt, int* lwork, int* info) {
                    typename T::value_type* rwork = new typename T::value_type[std::max(1, 2 * (*n))]; // as of MKL doc
                    T* work;
                    zgeev(jobvl, jobvr, n, a, lda, s, ldv, ldlv, rvd, ldrv, wkopt, lwork, rwork, info);
                    assert(*info == 0);
                    *lwork = OptimalSize(*wkopt);
                    work = (T*)std::malloc((*lwork) * sizeof(T));
                    zgeev(jobvl, jobvr, n, a, lda, s, ldv, ldlv, rvd, ldrv, work, lwork, rwork, info);
                    assert(*info == 0);
                    std::free(work);
                    delete[] rwork;
                }

                static void getrf(const int* m, const int* n, T* a, const int* lda, int* ipiv, int* info) {
                    zgetrf(m, n, a, lda, ipiv, info);
                }

                static void getri(const int* n, T* a, const int* lda, int* ipiv, int* info) {
                    T* work;
                    T wkopt;
                    int lwork = -1;
                    zgetri(n, a, lda, ipiv, &wkopt, &lwork, info);
                    assert(*info == 0);
                    lwork = OptimalSize(wkopt);
                    work = (T*)std::malloc(lwork * sizeof(T));
                    zgetri(n, a, lda, ipiv, work, &lwork, info);
                    assert(*info == 0);
                    std::free(work);
                }
            };

        }
    }
}

#endif
